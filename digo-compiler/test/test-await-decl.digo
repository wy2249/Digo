func digo_main(a int) void {

    var b future 
    
    b = try_return_one(1)

    res1, res2 := await b

}

async func try_return_one(a int) (int, bool) {
    
    a = 1
    return a+10,true
}

/*

; ModuleID = 'Digo'
source_filename = "Digo"

@str = private unnamed_addr constant [4 x i8] c"%s\0A\00"
@str.1 = private unnamed_addr constant [4 x i8] c"%s\0A\00"

declare void @printInt(i64)

declare void @printFloat(double)

declare void @printString(i8*)

declare i8* @CreateString(i8*)

declare i8* @CreateEmptyString()

declare i8* @AddString(i8*, i8*)

declare i64 @CompareString(i8*, i8*)

declare i8* @CloneString(i8*)

declare i64 @GetStringSize(i8*)

define void @digo_main(i64 %a) {
entry:
  %a1 = alloca i64
  store i64 %a, i64* %a1
  %b = alloca i8*
  %try_return_one_result = call i8* @digo_linker_async_call_try_return_one(i64 1)
  store i8* %try_return_one_result, i8** %b
  %res1 = alloca i64
  %res2 = alloca i1
  %b2 = load i8*, i8** %b
  %await_try_return_one_result = call { i64, i1 } @digo_linker_await_func_try_return_one(i8* %b2)
  %extracted_value = extractvalue { i64, i1 } %await_try_return_one_result, 0
  store i64 %extracted_value, i64* %res1
  %extracted_value3 = extractvalue { i64, i1 } %await_try_return_one_result, 1
  store i1 %extracted_value3, i1* %res2
  ret void
}

define { i64, i1 } @try_return_one(i64 %a) {
entry:
  %a1 = alloca i64
  store i64 %a, i64* %a1
  store i64 1, i64* %a1
  %a2 = load i64, i64* %a1
  %tmp = add i64 %a2, 10
  %mrv = insertvalue { i64, i1 } undef, i64 %tmp, 0
  %mrv3 = insertvalue { i64, i1 } %mrv, i1 true, 1
  ret { i64, i1 } %mrv3
}

declare { i64, i1 } @digo_linker_await_func_try_return_one(i8*)

declare i8* @digo_linker_async_call_try_return_one(i64)

*/


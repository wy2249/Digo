func digo_main() void {

    s := "hello"

    e,f := try_return_one_n(1, s)

    var b, c future 
    
    b = try_return_one(1, s)
    c = try_return_two(1, s)

    bb := try_return_one(1,"b")
    cc := try_return_two(1, "c")

    x, y := await bb
    m, n := await cc

}

async func try_return_one(b int, s string) (int,string) {
    
    return b+10, s+" world"
}

async remote func try_return_two(b int, s string) (int,string) {
    
    return b+10, s+" world"
}


func try_return_one_n(c int, s string) (int,string) {
    
    return c+10, s+"test"
}

/*

; ModuleID = 'Digo'
source_filename = "Digo"

@str = private unnamed_addr constant [4 x i8] c"%s\0A\00"
@createstr_ptr = private unnamed_addr constant [6 x i8] c"hello\00"
@createstr_ptr.1 = private unnamed_addr constant [2 x i8] c"b\00"
@createstr_ptr.2 = private unnamed_addr constant [2 x i8] c"c\00"
@str.3 = private unnamed_addr constant [4 x i8] c"%s\0A\00"
@createstr_ptr.4 = private unnamed_addr constant [7 x i8] c" world\00"
@str.5 = private unnamed_addr constant [4 x i8] c"%s\0A\00"
@createstr_ptr.6 = private unnamed_addr constant [7 x i8] c" world\00"
@str.7 = private unnamed_addr constant [4 x i8] c"%s\0A\00"
@createstr_ptr.8 = private unnamed_addr constant [5 x i8] c"test\00"

declare void @printInt(i64)

declare void @printFloat(double)

declare void @printString(i8*)

declare i8* @CreateString(i8*)

declare i8* @CreateEmptyString()

declare i8* @AddString(i8*, i8*)

declare i64 @CompareString(i8*, i8*)

declare i8* @CloneString(i8*)

declare i64 @GetStringSize(i8*)

define void @digo_main() {
entry:
  %s = alloca i8*
  %createstr = call i8* @CreateString(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @createstr_ptr, i32 0, i32 0))
  %clonestr = call i8* @CloneString(i8* %createstr)
  store i8* %clonestr, i8** %s
  %e = alloca i64
  %f = alloca i8*
  %s1 = load i8*, i8** %s
  %try_return_one_n_result = call { i64, i8* } @try_return_one_n(i64 1, i8* %s1)
  %extracted_value = extractvalue { i64, i8* } %try_return_one_n_result, 0
  store i64 %extracted_value, i64* %e
  %extracted_value2 = extractvalue { i64, i8* } %try_return_one_n_result, 1
  store i8* %extracted_value2, i8** %f
  %b = alloca i8*
  %c = alloca i8*
  %s3 = load i8*, i8** %s
  %try_return_one_result = call i8* @digo_linker_async_call_try_return_one(i64 1, i8* %s3)
  store i8* %try_return_one_result, i8** %b
  %s4 = load i8*, i8** %s
  %try_return_two_result = call i8* @digo_linker_async_call_try_return_two(i64 1, i8* %s4)
  store i8* %try_return_two_result, i8** %c
  %bb = alloca i8*
  %createstr5 = call i8* @CreateString(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @createstr_ptr.1, i32 0, i32 0))
  %try_return_one_result6 = call i8* @digo_linker_async_call_try_return_one(i64 1, i8* %createstr5)
  store i8* %try_return_one_result6, i8** %bb
  %cc = alloca i8*
  %createstr7 = call i8* @CreateString(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @createstr_ptr.2, i32 0, i32 0))
  %try_return_two_result8 = call i8* @digo_linker_async_call_try_return_two(i64 1, i8* %createstr7)
  store i8* %try_return_two_result8, i8** %cc
  %x = alloca i64
  %y = alloca i8*
  %bb9 = load i8*, i8** %bb
  %await_try_return_one_result = call { i64, i8* } @digo_linker_await_func_try_return_one(i8* %bb9)
  %extracted_value10 = extractvalue { i64, i8* } %await_try_return_one_result, 0
  store i64 %extracted_value10, i64* %x
  %extracted_value11 = extractvalue { i64, i8* } %await_try_return_one_result, 1
  store i8* %extracted_value11, i8** %y
  %m = alloca i64
  %n = alloca i8*
  %cc12 = load i8*, i8** %cc
  %await_try_return_two_result = call { i64, i8* } @digo_linker_await_func_try_return_two(i8* %cc12)
  %extracted_value13 = extractvalue { i64, i8* } %await_try_return_two_result, 0
  store i64 %extracted_value13, i64* %m
  %extracted_value14 = extractvalue { i64, i8* } %await_try_return_two_result, 1
  store i8* %extracted_value14, i8** %n
  ret void
}

define { i64, i8* } @try_return_one(i64 %b, i8* %s) {
entry:
  %b1 = alloca i64
  store i64 %b, i64* %b1
  %s2 = alloca i8*
  store i8* %s, i8** %s2
  %b3 = load i64, i64* %b1
  %tmp = add i64 %b3, 10
  %s4 = load i8*, i8** %s2
  %createstr = call i8* @CreateString(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @createstr_ptr.4, i32 0, i32 0))
  %addstr = call i8* @AddString(i8* %s4, i8* %createstr)
  %mrv = insertvalue { i64, i8* } undef, i64 %tmp, 0
  %mrv5 = insertvalue { i64, i8* } %mrv, i8* %addstr, 1
  ret { i64, i8* } %mrv5
}

define { i64, i8* } @try_return_two(i64 %b, i8* %s) {
entry:
  %b1 = alloca i64
  store i64 %b, i64* %b1
  %s2 = alloca i8*
  store i8* %s, i8** %s2
  %b3 = load i64, i64* %b1
  %tmp = add i64 %b3, 10
  %s4 = load i8*, i8** %s2
  %createstr = call i8* @CreateString(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @createstr_ptr.6, i32 0, i32 0))
  %addstr = call i8* @AddString(i8* %s4, i8* %createstr)
  %mrv = insertvalue { i64, i8* } undef, i64 %tmp, 0
  %mrv5 = insertvalue { i64, i8* } %mrv, i8* %addstr, 1
  ret { i64, i8* } %mrv5
}

define { i64, i8* } @try_return_one_n(i64 %c, i8* %s) {
entry:
  %c1 = alloca i64
  store i64 %c, i64* %c1
  %s2 = alloca i8*
  store i8* %s, i8** %s2
  %c3 = load i64, i64* %c1
  %tmp = add i64 %c3, 10
  %s4 = load i8*, i8** %s2
  %createstr = call i8* @CreateString(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @createstr_ptr.8, i32 0, i32 0))
  %addstr = call i8* @AddString(i8* %s4, i8* %createstr)
  %mrv = insertvalue { i64, i8* } undef, i64 %tmp, 0
  %mrv5 = insertvalue { i64, i8* } %mrv, i8* %addstr, 1
  ret { i64, i8* } %mrv5
}

declare { i64, i8* } @digo_linker_await_func_try_return_one(i8*)

declare i8* @digo_linker_async_call_try_return_one(i64, i8*)

declare { i64, i8* } @digo_linker_await_func_try_return_two(i8*)

declare i8* @digo_linker_async_call_try_return_two(i64, i8*)

*/

